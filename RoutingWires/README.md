1. This algorithm is a Breadth First Search that utilizes backtracking. The application of the algorithm is represented by a computer chip made up of a board. The board is of size nxn, and all points on it have their own coordinates. The board is filled with numbers: -1 represents an obstacle, 0s represent empty cells, and the rest of the board has numbers representing a start and an endpoint. For example, there will be two 1s on the board with 0s and -1s in between those 1s; you have to connect those 1s via a wire. My algorithm is split into 4 parts. The first part is BFS. BFS takes the first start and endpoint that we have to connect and finds a valid path. It will return true if there is a valid path and false if there isn't. The next method, placeWire, tracks the path found from BFS and places the wire. The third method, backtrack, checks if all start and endpoints after the initially placed wire also have a valid path. This needs to be done because some wire placements may cause other start and endpoints to be unreachable, so we need to make sure that our choice of wires doesn't mess up those in the future. Backtrack returns an ArrayList of all the placed wires. Finally, findPaths takes a board/computer chip and endpoints and returns an ArrayList of all the placed wires.
2. Here is an interesting board:
   
    0 0 0 0 
   
    0 0 2 0  

   -1 1 0 1 
   
    0 0 2 0


   On this board, the initial implementation of BFS will connect the start and endpoint of 1 with the shortest path, so it will connect it with a wire of length one going left to right. When this happens, 2 cannot be connected as every path has an existing wire or an obstacle. This is where backtracking comes into play. After a wire is placed down, the code looks at all future BFS placements. If any of these return null, then it knows to get rid of the wire that was initially placed down as it obstructs another start and endpoint. So in this case, when the 1s are connected, the code checks if connecting the 2s is valid. Since it is not, then it removes the wire connecting the 1s and instead connects the 2s first and the 1s second. Backtracking is very important as boards like this will not be able to connect all points.
3. Our algorithm uses BFS with backtracking to find a path for all potential wires. BFS is used to find the shortest path that connects a starting and ending point. Then backtracking is used to make sure that all wires will have a connection. If one wire is blocking endpoints from being connected, then that placed wire is removed. A key feature in this process is making our BFS method return true or false; it doesn't actually place the wire. All it does is say if there is a valid path available. The placeWire function actually places the wire down after it retraces what BFS did. BFS and backtracking together allow for optimized wire layouts with all endpoints having a connection and the wire itself being as short as possible.
4. The time complexity for the code is O(n(V + E)), where V is the number of vertices and E is the number of edges on a given board. BFS will take O(V+E) time as it searches through each cell and all connecting cells. The backtrack function will take O(n(V + E)) as it searches through all endpoints minus the ones already placed, which takes n time and calls BFS, which takes V+E time. Since findPaths calls backtrack, it takes O(n(V+E)), so all of the code takes O(n(V+E)). We tested a 100x100 board with 35 wires and 5 obstacles, which takes around 250 ms.
